/**

A Flow is a stream of values that can be observed. It is used to represent asynchronous data streams in Reaktor.
It exposes Kotlin.Flow to JS through C++ and JSI.

A flow can be used as follows

const flow = Flow<number>()

flow.emit(5)

// Start Collecting
flow.collect((value) => {
    console.log(value)
})


// You can store fn ref and stop collecting
const observer = flow.collect((value) => {
    console.log(value)
})
flow.stopCollecting(observer)


// Emit a new value to the flow
flow.emit(10)

// Stop the flow
flow.stop()

It is error agnostic, so you can use it to represent any kind of data stream.

 Improvements to be done ->
1. Strong Type Support
2. Automatic Type Generation
3. Replay Buffer

You must use discriminated unions to represent multiple types on TypeScript to represent possible states.
This is mapped back to Kotlin sealed classes and will be autogenerated by Reaktor. (TODO)

Example of a Flow with Error, Loading and Success states:
type ApiState =
    { type: 'error', error: Error } |
    { type: 'loading' } |
    { type: 'success', data: any }

const flow = Flow<ApiState>({ type: 'loading' })

 */

import { Nullable } from "../index";

type Observer<T> = (value: T) => void;

export interface Flow<T> {
    emit(value: T): void
    stop(): void
    collect(observer: Observer<T>): Observer<T>
    stopCollecting(observer: Observer<T>): void
    // asState(): T
}

export default class Queue<T> {
    values: T[] = [];

    empty = (): boolean => {
        return this.size() === 0;
    }

    size = (): number => {
        return this.values.length;
    }

    enqueue = (value: T) => {
        this.values.push(value);
    }

    /* Check if !Q.empty() */
    dequeue = (): T => {
        return this.values.shift()!;
    }
}


// Todo critical -> Catch JSError in invoker and return null
export class StateFlow<T> implements Flow<T> {
    observer: Nullable<Observer<T>>;
    /**
     * A queue is needed so that we can emit values before collecting
     * This is useful for example when you want to emit a value from a callback
     * before collecting the flow
     * And this supports emission from C++ as well as JS
     *
     * This is a FIFO queue without backpressure
     */
    queue = new Queue<T>()

    flushQueue = () => {
        while (!this.queue.empty()) {
            this.observer?.(this.queue.dequeue());
        }
    }

    /**
     * Returns the same function you passed
     * So you can use it to stopCollecting()
     */
    collect = (observer: Observer<T>) => {
        if (this.observer != null) {
            throw new Error("This version of flow does not support multiple observers, call the source function again")
        }
        this.observer = observer
        this.flushQueue();
        return observer
    }


    stopCollecting = (observer: Observer<T>) => {
        this.observer = null
    }

    emit = (value: T): void => {
        if (this.observer == null) {
            if (this.queue != null)
                this.queue.enqueue(value)
        } else {
            this.observer(value);
        }
    }

    stop = () => {
        this.observer = null;
    }
}

// ToDo later -> SharedFlow, this can replay values to multiple collectors


