package dev.shibasis.reaktor.compiler

import com.google.devtools.ksp.processing.*
import com.google.devtools.ksp.symbol.*
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.ksp.*
import java.time.Instant

class ReaktorProcessor(
    private val codeGenerator: CodeGenerator,
    private val logger: KSPLogger
) : SymbolProcessor {

    private val jsExportIgnoreFqName = "kotlin.js.JsExport.Ignore"

    override fun process(resolver: Resolver): List<KSAnnotated> {
        // Skip non-JS rounds (prevents common/jvm/native from getting kotlin.js.* code)
        if (!isJsRound(resolver)) {
            logger.info("ReaktorProcessor: non-JS round, skipping.")
            return emptyList()
        }

        logger.info("ReaktorProcessor: process() started")

        val annotatedFns = resolver.getSymbolsWithAnnotation(jsExportIgnoreFqName)
            .filterIsInstance<KSFunctionDeclaration>()
            .filter { Modifier.SUSPEND in it.modifiers }
            .toList()

        if (annotatedFns.isEmpty()) {
            logger.info("ReaktorProcessor: nothing to generate this round.")
            return emptyList()
        }

        annotatedFns
            .groupBy { it.containingFile ?: return@groupBy null }
            .filterKeys { it != null }
            .forEach { (file, fns) ->
                file ?: return@forEach
                logger.info("ReaktorProcessor: processing file ${file.fileName} with ${fns.size} suspend fn(s)")
                val visitor = PromiseVisitor(codeGenerator, logger, file)
                fns.forEach { it.accept(visitor, Unit) }
                visitor.write()
            }

        return emptyList()
    }

    /** Heuristic: Promise exists only on JS stdlib; good enough to gate generation. */
    private fun isJsRound(resolver: Resolver): Boolean {
        val name = resolver.getKSNameFromString("kotlin.js.Promise")
        return resolver.getClassDeclarationByName(name) != null
    }
}

class ReaktorProcessorProvider : SymbolProcessorProvider {
    override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor {
        environment.logger.info("ReaktorProcessorProvider: created")
        return ReaktorProcessor(environment.codeGenerator, environment.logger)
    }
}

private class PromiseVisitor(
    private val codeGenerator: CodeGenerator,
    private val logger: KSPLogger,
    private val sourceFile: KSFile
) : KSVisitorVoid() {

    private val generatedFunctions = mutableListOf<FunSpec>()
    private val pkgName = sourceFile.packageName.asString()

    override fun visitFunctionDeclaration(function: KSFunctionDeclaration, data: Unit) {
        buildWrapper(function)?.let { generatedFunctions += it }
    }

    fun write() {
        if (generatedFunctions.isEmpty()) return

        val outName = "JsPromiseWrappers_" + sourceFile.fileName.substringBeforeLast('.').sanitizeForFile()
        val fileSpec = FileSpec.builder(pkgName, outName)
            .addFileComment("Generated by Reaktor KSP at ${Instant.now()} from ${sourceFile.fileName}")
            // Add the coroutines-js extension import so GlobalScope.promise resolves.
            .addImport("kotlinx.coroutines", "promise")
            .apply { generatedFunctions.forEach { addFunction(it) } }
            .build()

        fileSpec.writeTo(codeGenerator, Dependencies(aggregating = false, sourceFile))
        logger.info("ReaktorProcessor: wrote $pkgName/$outName.kt with ${generatedFunctions.size} wrapper(s)")
    }

    private fun buildWrapper(fn: KSFunctionDeclaration): FunSpec? {
        val originalName = fn.simpleName.asString()
        val wrapperName = "${originalName}Async"

        val promise = ClassName("kotlin.js", "Promise")
        val jsExport = ClassName("kotlin.js", "JsExport")
        val jsName = ClassName("kotlin.js", "JsName")
        val globalScope = ClassName("kotlinx.coroutines", "GlobalScope")

        val returnType = fn.returnType?.toTypeName() ?: UNIT
        val promisedReturn = promise.parameterizedBy(returnType)

        val builder = FunSpec.builder(wrapperName)
            .returns(promisedReturn)
            .addModifiers(KModifier.PUBLIC)
            .addAnnotation(jsExport)
            .addAnnotation(AnnotationSpec.builder(jsName).addMember("%S", wrapperName).build())

        // 1) If the function is a member of a generic class, bring the class' type params into scope.
        val isMember = fn.parentDeclaration is KSClassDeclaration
        if (isMember) {
            val classDecl = fn.parentDeclaration as KSClassDeclaration
            // Add the class' type variables first so return/param TypeVariableNames (e.g., Response) are in scope.
            classDecl.typeParameters.forEach { builder.addTypeVariable(it.toTypeVariableName()) }

            // Receiver parameter uses the class with those type variables.
            val className = classDecl.toClassName()
            val recvTypeName =
                if (classDecl.typeParameters.isEmpty()) className
                else className.parameterizedBy(classDecl.typeParameters.map { it.toTypeVariableName() })
            builder.addParameter("receiver", recvTypeName)
        }

        // 2) Then add the function's own type parameters (avoid accidental name clashes if any).
        val classTpNames = (fn.parentDeclaration as? KSClassDeclaration)?.typeParameters?.map { it.name!!.getShortName() }?.toSet() ?: emptySet()
        fn.typeParameters.forEach { tp ->
            val name = tp.name!!.getShortName()
            if (name in classTpNames) {
                logger.warn("Reaktor: function type parameter `$name` shadows class type parameter; wrapper keeps the class one.")
                // If you need perfect shadowing semantics, we can alpha-rename function type params and rewrite types.
            } else {
                builder.addTypeVariable(tp.toTypeVariableName())
            }
        }

        var callTarget = originalName
        val hasExtensionReceiver = fn.extensionReceiver != null
        if (hasExtensionReceiver) {
            val recvName = "receiver"
            builder.addParameter(recvName, fn.extensionReceiver!!.toTypeName())
            callTarget = "$recvName.$originalName"
        } else if (isMember) {
            callTarget = "receiver.$originalName"
        }

        // Value parameters (preserve names; splat varargs)
        val callArgs = mutableListOf<String>()
        fn.parameters.forEach { p ->
            val name = p.name?.getShortName() ?: run {
                logger.warn("Reaktor: unnamed parameter in $originalName â€“ skipping function.")
                return null
            }
            val spec = ParameterSpec.builder(name, p.type.toTypeName())
            if (p.isVararg) spec.addModifiers(KModifier.VARARG)
            builder.addParameter(spec.build())
            callArgs += if (p.isVararg) "*$name" else name
        }

        // return GlobalScope.promise { <callTarget>(<args>) }
        val invocation = "$callTarget(${callArgs.joinToString()})"
        builder.addStatement("return %T.promise { %L }", globalScope, invocation)

        return builder.build()
    }
}

private fun String.sanitizeForFile(): String = replace(Regex("[^A-Za-z0-9_]"), "_")
